//usage: ./client 127.0.0.1 xxxx

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>

#include "common.h"
#include "crypto_utils.h"

#define MAX_INPUT 256

static ssize_t send_all(int fd, const void* buf, size_t len) {
    size_t total = 0;
    const char* p = buf;
    while (total < len) {
        ssize_t n = send(fd, p + total, len - total, 0);
        if (n <= 0) {
            if (n < 0 && errno == EINTR) continue;
            return -1;
        }
        total += n;
    }
    return total;
}

static ssize_t recv_all(int fd, void* buf, size_t len) {
    size_t total = 0;
    char* p = buf;
    while (total < len) {
        ssize_t n = recv(fd, p + total, len - total, 0);
        if (n <= 0) {
            if (n < 0 && errno == EINTR) continue;
            return -1;
        }
        total += n;
    }
    return total;
}

static int connect_to_server(const char* host, const char* port) {
    struct addrinfo hints, *res, *rp;
    int sockfd = -1;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family   = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    int err = getaddrinfo(host, port, &hints, &res);
    if (err != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(err));
        return -1;
    }

    for (rp = res; rp != NULL; rp = rp->ai_next) {
        sockfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (sockfd < 0) continue;

        if (connect(sockfd, rp->ai_addr, rp->ai_addrlen) == 0) break;

        close(sockfd);
        sockfd = -1;
    }

    freeaddrinfo(res);
    return sockfd;
}

static int authenticate(int sockfd) {
    char username[USERNAME_LEN];

    printf("Username: ");
    fflush(stdout);
    if (!fgets(username, sizeof(username), stdin)) return -1;

    char* nl = strchr(username, '\n');
    if (nl) *nl = '\0';

    ClientRequest req;
    memset(&req, 0, sizeof(req));
    snprintf(req.username, USERNAME_LEN, "%s", username);
    printf("DEBUG(client): sizeof(ClientRequest)=%zu, sending username='%s'\n", sizeof(ClientRequest), req.username);

    if (send_all(sockfd, &req, sizeof(req)) < 0) {
        perror("DEBUG(client): send_all(ClientRequest)");
        return -1;
    }

    ServerChallenge chal;
    if (recv_all(sockfd, &chal, sizeof(chal)) < 0) {
        fprintf(stderr, "Server closed (unknown user?)\n");
        return -1;
    }

    printf("DEBUG(client): received salt='%s' nonce_prefix=", chal.salt);
    for (int i = 0; i < 6; ++i) printf("%02x", chal.nonce[i]); //debugging - generated by chatGPT
    printf("...\n");

    char password[128];
    printf("Password: ");
    fflush(stdout);
    if (!fgets(password, sizeof(password), stdin)) return -1;

    nl = strchr(password, '\n');
    if (nl) *nl = '\0';

    unsigned char h_local[HASH_LEN];
    hash_password_salted(password, chal.salt, h_local);

    ClientResponse resp;
    compute_response(chal.nonce, h_local, resp.response);

    if (send_all(sockfd, &resp, sizeof(resp)) < 0) return -1;

    ServerResponse welcome;
    if (recv_all(sockfd, &welcome, sizeof(welcome)) < 0) return -1;

    if (!welcome.success) {
        printf("%s\n", welcome.message);
        return -1;
    }

    printf("%s\n", welcome.message);

    return 0;
}

static void trim_newline(char* s) {
    char* nl = strchr(s, '\n');
    if (nl) *nl = '\0';
}

static int parse_command(const char* line, ClientCommand* cmd) {
    memset(cmd, 0, sizeof(*cmd));
    cmd->type = CMD_INVALID;

    char copy[MAX_INPUT];
    strncpy(copy, line, sizeof(copy)-1);
    copy[sizeof(copy)-1] = '\0';

    trim_newline(copy);

    char* tok = strtok(copy, " ");
    if (!tok) return -1;

    if (strcmp(tok, "adduser") == 0) {
        cmd->type = CMD_ADDUSER;
        char* user = strtok(NULL, " ");
        char* pass = strtok(NULL, " ");
        if (!user || !pass) return -1;
        strncpy(cmd->arg1, user, sizeof(cmd->arg1)-1);
        strncpy(cmd->arg2, pass, sizeof(cmd->arg2)-1);
        return 0;
    }
    else if (strcmp(tok, "listusers") == 0) {
        cmd->type = CMD_LISTUSERS;
        return 0;
    }
    else if (strcmp(tok, "setrole") == 0) {
        cmd->type = CMD_SETROLE;
        char* user = strtok(NULL, " ");
        char* role = strtok(NULL, " ");
        if (!user || !role) return -1;
        strncpy(cmd->arg1, user, sizeof(cmd->arg1)-1);
        strncpy(cmd->arg2, role, sizeof(cmd->arg2)-1);
        return 0;
    }
    else if (strcmp(tok, "exit") == 0) {
        cmd->type = CMD_EXIT;
        return 0;
    }

    return -1;
}

static void command_loop(int sockfd) {
    char line[MAX_INPUT];

    while (1) {
        printf("> ");
        fflush(stdout);

        if (!fgets(line, sizeof(line), stdin)) break;

        ClientCommand cmd;
        if (parse_command(line, &cmd) < 0) {
            printf("Invalid command.\n");
            continue;
        }

        if (send_all(sockfd, &cmd, sizeof(cmd)) < 0) {
            printf("Connection lost.\n");
            break;
        }

        ServerResponse resp;
        if (recv_all(sockfd, &resp, sizeof(resp)) < 0) {
            printf("Connection lost.\n");
            break;
        }

        printf("%s\n", resp.message);

        if (cmd.type == CMD_EXIT) break;
    }
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <server_ip> <port>\n", argv[0]);
        return 1;
    }

    const char* host = argv[1];
    const char* port = argv[2];

    int sockfd = connect_to_server(host, port);
    if (sockfd < 0) {
        perror("connect");
        return 1;
    }

    // auth
    if (authenticate(sockfd) != 0) {
        close(sockfd);
        return 1;
    }

    command_loop(sockfd);

    close(sockfd);
    return 0;
}
